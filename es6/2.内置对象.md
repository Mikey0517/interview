# 内置对象

## 新增

（1）Map
    保存键值对
    任何值都可以作为 键和值

    与 Object 的区别
    -- Object 的键只能是字符串 和 Symbol
    -- Map 中的键是有序的，Object 无序
    -- Map 的键值对个数可通过 size 获取，Object 需自己计算
    -- Object 的键可能会和原型链上的键名冲突，Map 不会

    NaN 做键
    虽然 NaN 和 NaN 都不相等 (NaN !== NaN) // true
    但是作为键是相等的

    ```js
    var myMap = new Map();
    myMap.set(NaN, "not a number");
    
    myMap.get(NaN); // "not a number"
    
    var otherNaN = Number("foo");
    myMap.get(otherNaN); // "not a number"
    ```

    Map 遍历
    for let key of map.keys()
    for let value of map.values()
    for let [key, value] of map.entries()
    map.forEach((value, key))

    Map Array 转换
    let map = new Map([[0, 'zero'], [1, 'one']])
    let arr = Array.from(map) // [[0, 'zero'], [1, 'one']]

    Map 合并
    let fristMap = new Map([[0, 'zero'], [1, 'one']])
    let secondMap = new Map([[2, 'two']])
    let newMap = new Map([...fristMap, ...secondMap])
    有重复的键，后面的会覆盖前面的

（2）Set
    允许存储任何类型的唯一值
    -- +0 和 -0 是恒等的，不重复
    -- undefined 和 undefined 是恒等的，不重复
    -- NaN 和 NaN 不是恒等的，但是只能存一个，不重复

（3）Proxy 和 Reflect
    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy
    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect
    https://www.runoob.com/w3cnote/es6-reflect-proxy.html

（4）字符串 https://www.runoob.com/w3cnote/es6-string.html
    -- 字串的识别
        includes() 返回布尔值，判断是否找到参数字符串
        startsWith() 返回布尔值，判断参数字符串是否在原字符串的头部
        endsWith() 返回布尔值，判断参数字符串是否在原字符串的尾部
    -- 字符串重复
        repeat() 返回新的字符串，表示将字符串重复指定次数返回

        ```js
        console.log("Hello,".repeat(2));  // "Hello,Hello,"
        ```
        
    -- 字符串补全
        padStart() 返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串
        padEnd() 返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串

        ```js
        console.log("h".padStart(5,"o"));  // "ooooh"
        console.log("h".padEnd(5,"o"));    // "hoooo"
        console.log("h".padStart(5));      // "    h"
        ```
    -- 模板字符串

```js
class a {
  constructor(x, y) {
    console.log('a')
    this.x = x
    this.y = y
  }
}

class b extends a {
  constructor(x, y, z) {
    console.log('b start')
    super(x, y)
    this.z = z
    console.log('b end')
  }
}
```