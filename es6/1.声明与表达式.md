# 声明与表达式

## let 与 const

1. let
（1）块级作用域
    代码块内有效
（2）不能重复声明 var 可多次声明
（3）不存在变量提升

```js
console.log(a) //ReferenceError: a is not defined
let a = 2
console.log(b) //undefined
var b = 3
```

（4）暂时性死区
    在代码块内声明后，在代码块外部声明会报错
2. const
（1）简单类型声明后无法改变，复杂类型可改变属性
（2）同 let 表现一致

## 解构赋值

1. 数组解构赋值
（1）基本

```js
const [a, b] = [0, 1] // a = 0, b = 1
```

（2）嵌套

```js
const [a, [b, c]] = [0, [1, 2]] // a = 0, b = 1, c = 2
```

（3）可忽略

```js
const [, b] = [0, 1] // b = 1
```

（4）不完全解构 + 解构默认值

```js
const [a = 0, b] = [] // a = 0, b = undefined
```

（5）剩余运算符(必须在最后，不可以 [...a, b])

```js
const [a, ...b] = [0, 1, 2, 3] // a = 0, b = [1, 2, 3]
```

（6）解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据

```js
// 字符串解构
const [a, ...b] = 'hello' // a = 'h', b = ['e', 'l', 'l', 'o']
```

2. 对象解构赋值
  同数组结构类似

3. Symbol
  新的原始数据类型，表示独一无二的值
  因为是原始数据类型，所以不能用 new，Symbol('KK')

  | 方法                             | 普通属性 | 不可枚举属性 | Symbol 属性 | 原型链属性 |
  | Object.keys()                   |    √    |      X     |      X     |     X     |
  | Object.getOwnPropertyNames()    |    √    |      √     |      X     |     X     |
  | Object.getOwnPropertySymbols()  |    X    |      X     |      √     |     X     |
  | Reflect.ownKeys()               |    √    |      √     |      √     |     X     |
  | for in                          |    √    |      X     |      X     |     √     |

```js
let prototype = {
  q: 1
}

let obj = Object.create(prototype)
obj.a = 2
obj.b = 3
obj[Symbol('c')] = 4

Object.defineProperties(obj, {
  b: {
    enumerable: false
  }
})

console.log(Object.keys(obj)) // [a]
console.log(Object.getOwnPropertyNames(obj)) // [a, b]
console.log(Object.getOwnPropertySymbols(obj)) // [Symbol(c)]
console.log(Reflect.ownKeys(obj)) // [a, b, Symbol(c)]

for (let key in obj) {
  console.log(key) // a, q
}
```

（1）Symbol.for()
    首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索，Symbol(key) 无法被全局搜索
（2）Symbol.keyFor()
    返回一个被全局登记搜索的 Symbol 值的 key，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。

```js
let yellow = Symbol("Yellow");
let yellow1 = Symbol.for("Yellow");
yellow === yellow1;      // false
 
let yellow2 = Symbol.for("Yellow");
yellow1 === yellow2;     // true

Symbol.keyFor(yellow);    // undefined
Symbol.keyFor(yellow1);    // "Yellow"
```
